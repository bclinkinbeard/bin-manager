<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>BinManager Test Suite</title>
  <script src="https://cdn.jsdelivr.net/npm/fuse.js@7.0.0/dist/fuse.min.js"></script>
  <style>
    :root {
      --bg: #121212;
      --surface: #1e1e1e;
      --surface2: #2a2a2a;
      --accent: #ff9800;
      --text: #e0e0e0;
      --text-dim: #888;
      --danger: #e53935;
      --success: #43a047;
    }
    * { margin: 0; padding: 0; box-sizing: border-box; }
    body {
      font-family: 'Courier New', monospace;
      background: var(--bg);
      color: var(--text);
      padding: 20px;
      max-width: 900px;
      margin: 0 auto;
    }
    h1 {
      color: var(--accent);
      font-size: 20px;
      margin-bottom: 8px;
    }
    #summary {
      font-size: 14px;
      margin-bottom: 20px;
      padding: 12px;
      background: var(--surface);
      border-radius: 6px;
    }
    .suite-name {
      font-size: 15px;
      color: var(--accent);
      margin: 16px 0 8px;
      padding-bottom: 4px;
      border-bottom: 1px solid var(--surface2);
    }
    .test-result {
      padding: 6px 12px;
      margin: 2px 0;
      border-radius: 4px;
      font-size: 13px;
      background: var(--surface);
    }
    .test-result.pass { border-left: 3px solid var(--success); }
    .test-result.fail { border-left: 3px solid var(--danger); }
    .test-result .status {
      display: inline-block;
      width: 40px;
      font-weight: bold;
    }
    .test-result .status.pass { color: var(--success); }
    .test-result .status.fail { color: var(--danger); }
    .test-result .error {
      color: var(--danger);
      font-size: 11px;
      margin-top: 4px;
      padding-left: 44px;
    }
    #running {
      color: var(--accent);
      font-size: 14px;
      padding: 20px;
    }
  </style>
</head>
<body>
  <h1>BinManager Test Suite</h1>
  <div id="running">Running tests...</div>
  <div id="summary" style="display:none;"></div>
  <div id="results"></div>

  <script type="module">
    // ============================================================
    // MINIMAL TEST RUNNER
    // ============================================================

    const results = [];
    let currentSuite = '';

    function assert(condition, message) {
      if (!condition) throw new Error(message || 'Assertion failed');
    }

    function assertEqual(actual, expected, message) {
      if (actual !== expected) {
        throw new Error(
          (message || 'assertEqual failed') +
          ` — expected: ${JSON.stringify(expected)}, got: ${JSON.stringify(actual)}`
        );
      }
    }

    function assertDeepEqual(actual, expected, message) {
      if (JSON.stringify(actual) !== JSON.stringify(expected)) {
        throw new Error(
          (message || 'assertDeepEqual failed') +
          ` — expected: ${JSON.stringify(expected)}, got: ${JSON.stringify(actual)}`
        );
      }
    }

    async function test(name, fn) {
      try {
        await fn();
        results.push({ suite: currentSuite, name, passed: true, error: null });
      } catch (e) {
        results.push({ suite: currentSuite, name, passed: false, error: e.message });
      }
    }

    async function suite(name, fn) {
      currentSuite = name;
      await fn();
    }

    function renderResults() {
      const container = document.getElementById('results');
      const summary = document.getElementById('summary');
      document.getElementById('running').style.display = 'none';
      summary.style.display = 'block';

      const passed = results.filter((r) => r.passed).length;
      const failed = results.filter((r) => !r.passed).length;
      const total = results.length;

      summary.innerHTML =
        `<span style="color:var(--success);">${passed} passed</span> · ` +
        `<span style="color:${failed ? 'var(--danger)' : 'var(--text-dim)'};">${failed} failed</span> · ` +
        `${total} total`;

      let html = '';
      let lastSuite = '';
      for (const r of results) {
        if (r.suite !== lastSuite) {
          html += `<div class="suite-name">${r.suite}</div>`;
          lastSuite = r.suite;
        }
        const cls = r.passed ? 'pass' : 'fail';
        html += `<div class="test-result ${cls}">`;
        html += `<span class="status ${cls}">${r.passed ? 'PASS' : 'FAIL'}</span> ${r.name}`;
        if (r.error) {
          html += `<div class="error">${r.error}</div>`;
        }
        html += `</div>`;
      }
      container.innerHTML = html;
    }

    // ============================================================
    // TEST DATABASE LAYER (isolated from production)
    // ============================================================

    const TEST_DB_NAME = 'binManagerDB_test';
    const TEST_DB_VERSION = 1;
    let testDb = null;
    let testDataVersion = 0;

    function dbOpen() {
      return new Promise((resolve, reject) => {
        if (testDb) return resolve(testDb);
        const req = indexedDB.open(TEST_DB_NAME, TEST_DB_VERSION);
        req.onupgradeneeded = (e) => {
          const d = e.target.result;
          if (!d.objectStoreNames.contains('bins')) {
            d.createObjectStore('bins', { keyPath: 'id' });
          }
          if (!d.objectStoreNames.contains('items')) {
            const items = d.createObjectStore('items', { keyPath: 'id' });
            items.createIndex('binId', 'binId', { unique: false });
          }
        };
        req.onsuccess = (e) => { testDb = e.target.result; resolve(testDb); };
        req.onerror = (e) => reject(e.target.error);
      });
    }

    function dbTx(store, mode) {
      return testDb.transaction(store, mode).objectStore(store);
    }

    function dbReq(r) {
      return new Promise((resolve, reject) => {
        r.onsuccess = () => resolve(r.result);
        r.onerror = () => reject(r.error);
      });
    }

    async function dbGetAllBins() {
      await dbOpen();
      return dbReq(dbTx('bins', 'readonly').getAll());
    }

    async function dbGetBin(id) {
      await dbOpen();
      return dbReq(dbTx('bins', 'readonly').get(id));
    }

    async function dbPutBin(bin) {
      await dbOpen();
      const result = await dbReq(dbTx('bins', 'readwrite').put(bin));
      testDataVersion++;
      return result;
    }

    async function dbDeleteBin(id) {
      await dbOpen();
      const items = await dbGetItemsByBin(id);
      await dbReq(dbTx('bins', 'readwrite').delete(id));
      if (items.length > 0) {
        const store = dbTx('items', 'readwrite');
        for (const item of items) { store.delete(item.id); }
      }
      testDataVersion++;
    }

    async function dbGetAllItems() {
      await dbOpen();
      return dbReq(dbTx('items', 'readonly').getAll());
    }

    async function dbGetItem(id) {
      await dbOpen();
      return dbReq(dbTx('items', 'readonly').get(id));
    }

    async function dbGetItemsByBin(binId) {
      await dbOpen();
      const store = dbTx('items', 'readonly');
      return dbReq(store.index('binId').getAll(binId));
    }

    async function dbPutItem(item) {
      await dbOpen();
      const result = await dbReq(dbTx('items', 'readwrite').put(item));
      testDataVersion++;
      return result;
    }

    async function dbDeleteItem(id) {
      await dbOpen();
      await dbReq(dbTx('items', 'readwrite').delete(id));
      testDataVersion++;
    }

    async function dbGetCounts() {
      await dbOpen();
      const bins = await dbReq(dbTx('bins', 'readonly').count());
      const items = await dbReq(dbTx('items', 'readonly').count());
      return { bins, items };
    }

    async function dbGetNextBinNumber() {
      const bins = await dbGetAllBins();
      let max = 0;
      for (const b of bins) {
        const m = b.id.match(/^BIN-(\d+)$/);
        if (m) max = Math.max(max, parseInt(m[1], 10));
      }
      return max + 1;
    }

    async function dbExportAll() {
      const bins = await dbGetAllBins();
      const items = await dbGetAllItems();
      return { bins, items, exportedAt: new Date().toISOString() };
    }

    async function dbImportAll(data, mode) {
      await dbOpen();
      if (mode === 'replace') {
        await dbReq(dbTx('bins', 'readwrite').clear());
        await dbReq(dbTx('items', 'readwrite').clear());
      }
      for (const bin of (data.bins || [])) {
        await dbReq(dbTx('bins', 'readwrite').put(bin));
      }
      for (const item of (data.items || [])) {
        await dbReq(dbTx('items', 'readwrite').put(item));
      }
      testDataVersion++;
    }

    function dbGetDataVersion() {
      return testDataVersion;
    }

    async function clearTestDb() {
      await dbOpen();
      await dbReq(dbTx('bins', 'readwrite').clear());
      await dbReq(dbTx('items', 'readwrite').clear());
    }

    async function destroyTestDb() {
      if (testDb) {
        testDb.close();
        testDb = null;
      }
      return new Promise((resolve) => {
        const req = indexedDB.deleteDatabase(TEST_DB_NAME);
        req.onsuccess = () => resolve();
        req.onerror = () => resolve();
        req.onblocked = () => resolve();
      });
    }

    // ============================================================
    // FEATURE FUNCTIONS UNDER TEST
    // (These define expected behavior for new features.
    //  When features are implemented, replace these with imports.)
    // ============================================================

    // -- Photo Compression (Feature 4) --

    function compressPhoto(dataUrl, maxDimension = 800, quality = 0.7) {
      return new Promise((resolve, reject) => {
        const img = new Image();
        img.onload = () => {
          let { width, height } = img;
          if (width > maxDimension || height > maxDimension) {
            if (width > height) {
              height = Math.round(height * (maxDimension / width));
              width = maxDimension;
            } else {
              width = Math.round(width * (maxDimension / height));
              height = maxDimension;
            }
          }
          const canvas = document.createElement('canvas');
          canvas.width = width;
          canvas.height = height;
          const ctx = canvas.getContext('2d');
          ctx.drawImage(img, 0, 0, width, height);
          resolve({
            dataUrl: canvas.toDataURL('image/jpeg', quality),
            width,
            height
          });
        };
        img.onerror = () => reject(new Error('Failed to load image'));
        img.src = dataUrl;
      });
    }

    // -- Item Sorting (Feature 5) --

    function sortItems(items, sortBy) {
      const sorted = [...items];
      switch (sortBy) {
        case 'newest':
          sorted.sort((a, b) => new Date(b.addedAt) - new Date(a.addedAt));
          break;
        case 'oldest':
          sorted.sort((a, b) => new Date(a.addedAt) - new Date(b.addedAt));
          break;
        case 'a-z':
          sorted.sort((a, b) => (a.description || '').localeCompare(b.description || ''));
          break;
        case 'z-a':
          sorted.sort((a, b) => (b.description || '').localeCompare(a.description || ''));
          break;
        default:
          break;
      }
      return sorted;
    }

    // -- Tag Parsing (Feature 6) --

    function parseTags(input) {
      if (!input || typeof input !== 'string') return [];
      return [...new Set(
        input
          .split(',')
          .map((t) => t.trim().toLowerCase())
          .filter((t) => t.length > 0)
      )];
    }

    // -- Archive Filtering (Feature 8) --

    function filterBins(bins, { showArchived = false } = {}) {
      if (showArchived) return bins;
      return bins.filter((b) => !b.archived);
    }

    // -- Pagination (Feature 9) --

    function paginate(items, page, pageSize = 20) {
      const start = (page - 1) * pageSize;
      return {
        items: items.slice(start, start + pageSize),
        page,
        pageSize,
        totalItems: items.length,
        totalPages: Math.ceil(items.length / pageSize),
        hasNext: start + pageSize < items.length,
        hasPrev: page > 1,
      };
    }

    // -- Import Validation (Feature 1) --

    function validateImportData(data) {
      const errors = [];
      if (!data || typeof data !== 'object') {
        return { valid: false, errors: ['Data must be a non-null object'] };
      }
      if (!Array.isArray(data.bins)) {
        errors.push('Missing or invalid "bins" array');
      } else {
        data.bins.forEach((bin, i) => {
          if (!bin.id || typeof bin.id !== 'string') {
            errors.push(`bins[${i}]: missing or invalid "id"`);
          }
        });
      }
      if (!Array.isArray(data.items)) {
        errors.push('Missing or invalid "items" array');
      } else {
        data.items.forEach((item, i) => {
          if (!item.id || typeof item.id !== 'string') {
            errors.push(`items[${i}]: missing or invalid "id"`);
          }
          if (!item.binId || typeof item.binId !== 'string') {
            errors.push(`items[${i}]: missing or invalid "binId"`);
          }
        });
      }
      return { valid: errors.length === 0, errors };
    }

    // ============================================================
    // HELPER: create a test image as a data URL
    // ============================================================

    function createTestImageDataUrl(width, height) {
      const canvas = document.createElement('canvas');
      canvas.width = width;
      canvas.height = height;
      const ctx = canvas.getContext('2d');
      ctx.fillStyle = '#ff9800';
      ctx.fillRect(0, 0, width, height);
      ctx.fillStyle = '#121212';
      ctx.fillRect(10, 10, width - 20, height - 20);
      return canvas.toDataURL('image/png');
    }

    // ============================================================
    // TEST SUITES
    // ============================================================

    async function runAllTests() {
      // Initialize test database
      await dbOpen();
      await clearTestDb();

      // --------------------------------------------------------
      // SUITE: DB Core — Bins CRUD
      // --------------------------------------------------------
      await suite('DB Core — Bins CRUD', async () => {
        await clearTestDb();

        await test('putBin creates a bin and getBin retrieves it', async () => {
          const bin = { id: 'BIN-001', name: 'Resistors', location: 'Shelf A', description: 'Mixed resistors', createdAt: '2026-01-15T10:00:00Z' };
          await dbPutBin(bin);
          const result = await dbGetBin('BIN-001');
          assertEqual(result.id, 'BIN-001');
          assertEqual(result.name, 'Resistors');
          assertEqual(result.location, 'Shelf A');
        });

        await test('putBin overwrites existing bin (upsert)', async () => {
          await dbPutBin({ id: 'BIN-001', name: 'Updated Name', location: 'Shelf B', description: 'Updated', createdAt: '2026-01-15T10:00:00Z' });
          const result = await dbGetBin('BIN-001');
          assertEqual(result.name, 'Updated Name');
          assertEqual(result.location, 'Shelf B');
        });

        await test('getAllBins returns all bins', async () => {
          await dbPutBin({ id: 'BIN-002', name: 'Capacitors', location: 'Shelf A', description: '', createdAt: '2026-01-15T11:00:00Z' });
          const bins = await dbGetAllBins();
          assert(bins.length >= 2, `Expected at least 2 bins, got ${bins.length}`);
        });

        await test('getBin returns undefined for nonexistent bin', async () => {
          const result = await dbGetBin('BIN-999');
          assertEqual(result, undefined);
        });

        await test('deleteBin removes the bin', async () => {
          await dbPutBin({ id: 'BIN-DEL', name: 'To Delete', location: '', description: '', createdAt: '2026-01-15T12:00:00Z' });
          await dbDeleteBin('BIN-DEL');
          const result = await dbGetBin('BIN-DEL');
          assertEqual(result, undefined);
        });

        await test('deleteBin also removes associated items', async () => {
          await dbPutBin({ id: 'BIN-DEL2', name: 'Delete With Items', location: '', description: '', createdAt: '2026-01-15T12:00:00Z' });
          await dbPutItem({ id: 'item-del-1', binId: 'BIN-DEL2', description: 'Item 1', photo: null, addedAt: '2026-01-15T12:01:00Z' });
          await dbPutItem({ id: 'item-del-2', binId: 'BIN-DEL2', description: 'Item 2', photo: null, addedAt: '2026-01-15T12:02:00Z' });
          await dbDeleteBin('BIN-DEL2');
          const items = await dbGetItemsByBin('BIN-DEL2');
          assertEqual(items.length, 0, 'Expected 0 items after bin deletion');
        });
      });

      // --------------------------------------------------------
      // SUITE: DB Core — Items CRUD
      // --------------------------------------------------------
      await suite('DB Core — Items CRUD', async () => {
        await clearTestDb();
        await dbPutBin({ id: 'BIN-100', name: 'Test Bin', location: '', description: '', createdAt: '2026-01-15T10:00:00Z' });

        await test('putItem creates an item and getItem retrieves it', async () => {
          const item = { id: 'item-001', binId: 'BIN-100', description: 'Screwdriver', photo: null, addedAt: '2026-01-16T10:00:00Z' };
          await dbPutItem(item);
          const result = await dbGetItem('item-001');
          assertEqual(result.id, 'item-001');
          assertEqual(result.description, 'Screwdriver');
          assertEqual(result.binId, 'BIN-100');
        });

        await test('getItemsByBin returns only items for that bin', async () => {
          await dbPutItem({ id: 'item-002', binId: 'BIN-100', description: 'Hammer', photo: null, addedAt: '2026-01-16T10:01:00Z' });
          await dbPutItem({ id: 'item-003', binId: 'BIN-OTHER', description: 'Unrelated', photo: null, addedAt: '2026-01-16T10:02:00Z' });
          const items = await dbGetItemsByBin('BIN-100');
          assert(items.every((i) => i.binId === 'BIN-100'), 'All items should belong to BIN-100');
          assert(items.length === 2, `Expected 2 items in BIN-100, got ${items.length}`);
        });

        await test('putItem overwrites existing item (edit)', async () => {
          await dbPutItem({ id: 'item-001', binId: 'BIN-100', description: 'Phillips Screwdriver', photo: null, addedAt: '2026-01-16T10:00:00Z' });
          const result = await dbGetItem('item-001');
          assertEqual(result.description, 'Phillips Screwdriver');
        });

        await test('deleteItem removes only the target item', async () => {
          await dbDeleteItem('item-002');
          const deleted = await dbGetItem('item-002');
          assertEqual(deleted, undefined, 'Deleted item should be undefined');
          const remaining = await dbGetItemsByBin('BIN-100');
          assertEqual(remaining.length, 1, 'One item should remain in BIN-100');
        });

        await test('getAllItems returns items across all bins', async () => {
          const items = await dbGetAllItems();
          assert(items.length >= 2, `Expected at least 2 total items, got ${items.length}`);
        });
      });

      // --------------------------------------------------------
      // SUITE: DB Core — Counts & Next Bin Number
      // --------------------------------------------------------
      await suite('DB Core — Counts & Next Bin Number', async () => {
        await clearTestDb();

        await test('getCounts returns {bins: 0, items: 0} on empty db', async () => {
          const c = await dbGetCounts();
          assertEqual(c.bins, 0);
          assertEqual(c.items, 0);
        });

        await test('getCounts reflects insertions', async () => {
          await dbPutBin({ id: 'BIN-001', name: '', location: '', description: '', createdAt: '2026-01-15T10:00:00Z' });
          await dbPutBin({ id: 'BIN-002', name: '', location: '', description: '', createdAt: '2026-01-15T10:00:00Z' });
          await dbPutItem({ id: 'i1', binId: 'BIN-001', description: 'X', photo: null, addedAt: '2026-01-16T10:00:00Z' });
          const c = await dbGetCounts();
          assertEqual(c.bins, 2);
          assertEqual(c.items, 1);
        });

        await test('getNextBinNumber returns 1 on empty db', async () => {
          await clearTestDb();
          const next = await dbGetNextBinNumber();
          assertEqual(next, 1);
        });

        await test('getNextBinNumber returns max+1', async () => {
          await dbPutBin({ id: 'BIN-005', name: '', location: '', description: '', createdAt: '2026-01-15T10:00:00Z' });
          await dbPutBin({ id: 'BIN-012', name: '', location: '', description: '', createdAt: '2026-01-15T10:00:00Z' });
          const next = await dbGetNextBinNumber();
          assertEqual(next, 13);
        });

        await test('getNextBinNumber ignores non-standard IDs', async () => {
          await clearTestDb();
          await dbPutBin({ id: 'CUSTOM-ID', name: '', location: '', description: '', createdAt: '2026-01-15T10:00:00Z' });
          await dbPutBin({ id: 'BIN-003', name: '', location: '', description: '', createdAt: '2026-01-15T10:00:00Z' });
          const next = await dbGetNextBinNumber();
          assertEqual(next, 4, 'Should only consider BIN-### format');
        });
      });

      // --------------------------------------------------------
      // SUITE: Data Export
      // --------------------------------------------------------
      await suite('Data Export', async () => {
        await clearTestDb();

        await test('exportAll returns bins, items, and exportedAt', async () => {
          await dbPutBin({ id: 'BIN-001', name: 'A', location: 'L', description: 'D', createdAt: '2026-01-15T10:00:00Z' });
          await dbPutItem({ id: 'i1', binId: 'BIN-001', description: 'X', photo: null, addedAt: '2026-01-16T10:00:00Z' });
          const data = await dbExportAll();
          assert(Array.isArray(data.bins), 'bins should be an array');
          assert(Array.isArray(data.items), 'items should be an array');
          assert(typeof data.exportedAt === 'string', 'exportedAt should be a string');
          assertEqual(data.bins.length, 1);
          assertEqual(data.items.length, 1);
        });

        await test('exportAll on empty db returns empty arrays', async () => {
          await clearTestDb();
          const data = await dbExportAll();
          assertEqual(data.bins.length, 0);
          assertEqual(data.items.length, 0);
        });
      });

      // --------------------------------------------------------
      // SUITE: Data Import — Replace Mode
      // --------------------------------------------------------
      await suite('Data Import — Replace Mode', async () => {
        await clearTestDb();

        await test('import with replace mode clears existing data', async () => {
          await dbPutBin({ id: 'BIN-OLD', name: 'Old', location: '', description: '', createdAt: '2026-01-01T00:00:00Z' });
          await dbPutItem({ id: 'item-old', binId: 'BIN-OLD', description: 'Old item', photo: null, addedAt: '2026-01-01T00:00:00Z' });

          const importData = {
            bins: [{ id: 'BIN-NEW', name: 'New', location: 'New Loc', description: 'Imported', createdAt: '2026-02-01T00:00:00Z' }],
            items: [{ id: 'item-new', binId: 'BIN-NEW', description: 'New item', photo: null, addedAt: '2026-02-01T00:00:00Z' }],
          };
          await dbImportAll(importData, 'replace');

          const oldBin = await dbGetBin('BIN-OLD');
          assertEqual(oldBin, undefined, 'Old bin should be gone after replace');
          const newBin = await dbGetBin('BIN-NEW');
          assertEqual(newBin.name, 'New');
          const counts = await dbGetCounts();
          assertEqual(counts.bins, 1);
          assertEqual(counts.items, 1);
        });

        await test('import with replace mode handles empty import data', async () => {
          await dbPutBin({ id: 'BIN-X', name: 'X', location: '', description: '', createdAt: '2026-01-01T00:00:00Z' });
          await dbImportAll({ bins: [], items: [] }, 'replace');
          const counts = await dbGetCounts();
          assertEqual(counts.bins, 0, 'All bins cleared');
          assertEqual(counts.items, 0, 'All items cleared');
        });
      });

      // --------------------------------------------------------
      // SUITE: Data Import — Merge Mode
      // --------------------------------------------------------
      await suite('Data Import — Merge Mode', async () => {
        await clearTestDb();

        await test('import with merge mode preserves existing data', async () => {
          await dbPutBin({ id: 'BIN-001', name: 'Existing', location: 'Shelf A', description: '', createdAt: '2026-01-01T00:00:00Z' });
          await dbPutItem({ id: 'item-exist', binId: 'BIN-001', description: 'Existing item', photo: null, addedAt: '2026-01-01T00:00:00Z' });

          const importData = {
            bins: [{ id: 'BIN-002', name: 'Imported', location: 'Shelf B', description: '', createdAt: '2026-02-01T00:00:00Z' }],
            items: [{ id: 'item-import', binId: 'BIN-002', description: 'Imported item', photo: null, addedAt: '2026-02-01T00:00:00Z' }],
          };
          await dbImportAll(importData, 'merge');

          const bin1 = await dbGetBin('BIN-001');
          assertEqual(bin1.name, 'Existing', 'Existing bin should be preserved');
          const bin2 = await dbGetBin('BIN-002');
          assertEqual(bin2.name, 'Imported', 'Imported bin should exist');
          const counts = await dbGetCounts();
          assertEqual(counts.bins, 2);
          assertEqual(counts.items, 2);
        });

        await test('merge mode overwrites bins with same ID', async () => {
          await clearTestDb();
          await dbPutBin({ id: 'BIN-001', name: 'Original', location: 'Loc A', description: '', createdAt: '2026-01-01T00:00:00Z' });
          await dbImportAll({
            bins: [{ id: 'BIN-001', name: 'Overwritten', location: 'Loc B', description: '', createdAt: '2026-02-01T00:00:00Z' }],
            items: [],
          }, 'merge');
          const bin = await dbGetBin('BIN-001');
          assertEqual(bin.name, 'Overwritten', 'Merge uses put(), which overwrites matching IDs');
        });
      });

      // --------------------------------------------------------
      // SUITE: Data Import — Validation
      // --------------------------------------------------------
      await suite('Data Import — Validation', async () => {

        await test('validates null data', () => {
          const result = validateImportData(null);
          assertEqual(result.valid, false);
          assert(result.errors.length > 0, 'Should have errors');
        });

        await test('validates non-object data', () => {
          const result = validateImportData('not an object');
          assertEqual(result.valid, false);
        });

        await test('validates missing bins array', () => {
          const result = validateImportData({ items: [] });
          assertEqual(result.valid, false);
          assert(result.errors.some((e) => e.includes('bins')), 'Should mention bins');
        });

        await test('validates missing items array', () => {
          const result = validateImportData({ bins: [] });
          assertEqual(result.valid, false);
          assert(result.errors.some((e) => e.includes('items')), 'Should mention items');
        });

        await test('validates bin without id', () => {
          const result = validateImportData({ bins: [{ name: 'No ID' }], items: [] });
          assertEqual(result.valid, false);
          assert(result.errors.some((e) => e.includes('bins[0]')), 'Should identify bin index');
        });

        await test('validates item without binId', () => {
          const result = validateImportData({ bins: [], items: [{ id: 'i1', description: 'test' }] });
          assertEqual(result.valid, false);
          assert(result.errors.some((e) => e.includes('binId')), 'Should mention binId');
        });

        await test('validates correct data passes', () => {
          const result = validateImportData({
            bins: [{ id: 'BIN-001', name: 'Test' }],
            items: [{ id: 'i1', binId: 'BIN-001', description: 'X' }],
          });
          assertEqual(result.valid, true);
          assertEqual(result.errors.length, 0);
        });

        await test('validates empty bins and items arrays passes', () => {
          const result = validateImportData({ bins: [], items: [] });
          assertEqual(result.valid, true);
        });
      });

      // --------------------------------------------------------
      // SUITE: Photo Compression
      // --------------------------------------------------------
      await suite('Photo Compression', async () => {

        await test('compresses landscape image to max 800px width', async () => {
          const src = createTestImageDataUrl(1600, 1200);
          const result = await compressPhoto(src, 800, 0.7);
          assertEqual(result.width, 800);
          assertEqual(result.height, 600);
        });

        await test('compresses portrait image to max 800px height', async () => {
          const src = createTestImageDataUrl(900, 1800);
          const result = await compressPhoto(src, 800, 0.7);
          assertEqual(result.width, 400);
          assertEqual(result.height, 800);
        });

        await test('does not upscale small images', async () => {
          const src = createTestImageDataUrl(400, 300);
          const result = await compressPhoto(src, 800, 0.7);
          assertEqual(result.width, 400);
          assertEqual(result.height, 300);
        });

        await test('compresses square image correctly', async () => {
          const src = createTestImageDataUrl(2000, 2000);
          const result = await compressPhoto(src, 800, 0.7);
          assertEqual(result.width, 800);
          assertEqual(result.height, 800);
        });

        await test('output is a JPEG data URL', async () => {
          const src = createTestImageDataUrl(1000, 500);
          const result = await compressPhoto(src, 800, 0.7);
          assert(result.dataUrl.startsWith('data:image/jpeg'), 'Should be JPEG format');
        });

        await test('compressed image is smaller than original PNG', async () => {
          const src = createTestImageDataUrl(1600, 1200);
          const result = await compressPhoto(src, 800, 0.7);
          assert(result.dataUrl.length < src.length, 'Compressed should be smaller than original');
        });

        await test('handles exactly max dimension (no resize needed)', async () => {
          const src = createTestImageDataUrl(800, 600);
          const result = await compressPhoto(src, 800, 0.7);
          assertEqual(result.width, 800);
          assertEqual(result.height, 600);
        });

        await test('custom max dimension works', async () => {
          const src = createTestImageDataUrl(1000, 500);
          const result = await compressPhoto(src, 400, 0.5);
          assertEqual(result.width, 400);
          assertEqual(result.height, 200);
        });
      });

      // --------------------------------------------------------
      // SUITE: Item Sorting
      // --------------------------------------------------------
      await suite('Item Sorting', async () => {
        const items = [
          { id: '1', description: 'Banana', addedAt: '2026-01-15T10:00:00Z' },
          { id: '2', description: 'Apple', addedAt: '2026-01-16T10:00:00Z' },
          { id: '3', description: 'Cherry', addedAt: '2026-01-14T10:00:00Z' },
          { id: '4', description: 'Date', addedAt: '2026-01-17T10:00:00Z' },
        ];

        await test('sort newest first', () => {
          const sorted = sortItems(items, 'newest');
          assertEqual(sorted[0].description, 'Date');
          assertEqual(sorted[1].description, 'Apple');
          assertEqual(sorted[2].description, 'Banana');
          assertEqual(sorted[3].description, 'Cherry');
        });

        await test('sort oldest first', () => {
          const sorted = sortItems(items, 'oldest');
          assertEqual(sorted[0].description, 'Cherry');
          assertEqual(sorted[3].description, 'Date');
        });

        await test('sort A-Z', () => {
          const sorted = sortItems(items, 'a-z');
          assertEqual(sorted[0].description, 'Apple');
          assertEqual(sorted[1].description, 'Banana');
          assertEqual(sorted[2].description, 'Cherry');
          assertEqual(sorted[3].description, 'Date');
        });

        await test('sort Z-A', () => {
          const sorted = sortItems(items, 'z-a');
          assertEqual(sorted[0].description, 'Date');
          assertEqual(sorted[3].description, 'Apple');
        });

        await test('sort does not mutate original array', () => {
          const original = [...items];
          sortItems(items, 'a-z');
          assertDeepEqual(items, original, 'Original array should be unchanged');
        });

        await test('sort handles empty array', () => {
          const sorted = sortItems([], 'newest');
          assertEqual(sorted.length, 0);
        });

        await test('sort handles items with missing description', () => {
          const incomplete = [
            { id: '1', description: 'Zebra', addedAt: '2026-01-15T10:00:00Z' },
            { id: '2', description: '', addedAt: '2026-01-16T10:00:00Z' },
            { id: '3', addedAt: '2026-01-17T10:00:00Z' },
          ];
          const sorted = sortItems(incomplete, 'a-z');
          assertEqual(sorted.length, 3, 'Should handle missing descriptions without error');
        });

        await test('unknown sort key returns items in original order', () => {
          const sorted = sortItems(items, 'unknown');
          assertDeepEqual(
            sorted.map((i) => i.id),
            items.map((i) => i.id),
            'Unknown sort key should preserve order'
          );
        });
      });

      // --------------------------------------------------------
      // SUITE: Tag Parsing
      // --------------------------------------------------------
      await suite('Tag Parsing', async () => {

        await test('parses comma-separated tags', () => {
          const tags = parseTags('electronics, resistors, 10k');
          assertDeepEqual(tags, ['electronics', 'resistors', '10k']);
        });

        await test('trims whitespace from tags', () => {
          const tags = parseTags('  foo  ,  bar  ,  baz  ');
          assertDeepEqual(tags, ['foo', 'bar', 'baz']);
        });

        await test('lowercases tags', () => {
          const tags = parseTags('Electronics, RESISTORS, MiXeD');
          assertDeepEqual(tags, ['electronics', 'resistors', 'mixed']);
        });

        await test('removes duplicates', () => {
          const tags = parseTags('foo, bar, foo, BAR, baz');
          assertDeepEqual(tags, ['foo', 'bar', 'baz']);
        });

        await test('filters empty tags from trailing commas', () => {
          const tags = parseTags('foo, , bar, ,');
          assertDeepEqual(tags, ['foo', 'bar']);
        });

        await test('returns empty array for empty string', () => {
          assertDeepEqual(parseTags(''), []);
        });

        await test('returns empty array for null input', () => {
          assertDeepEqual(parseTags(null), []);
        });

        await test('returns empty array for undefined input', () => {
          assertDeepEqual(parseTags(undefined), []);
        });

        await test('returns empty array for non-string input', () => {
          assertDeepEqual(parseTags(42), []);
        });

        await test('single tag (no commas)', () => {
          assertDeepEqual(parseTags('electronics'), ['electronics']);
        });

        await test('handles only-whitespace tags', () => {
          const tags = parseTags(' , ,  ,');
          assertDeepEqual(tags, []);
        });
      });

      // --------------------------------------------------------
      // SUITE: Archive Filtering
      // --------------------------------------------------------
      await suite('Archive Filtering', async () => {
        const bins = [
          { id: 'BIN-001', name: 'Active 1', archived: false },
          { id: 'BIN-002', name: 'Archived 1', archived: true },
          { id: 'BIN-003', name: 'Active 2', archived: false },
          { id: 'BIN-004', name: 'Archived 2', archived: true },
          { id: 'BIN-005', name: 'No flag set' },
        ];

        await test('hides archived bins by default', () => {
          const result = filterBins(bins);
          assertEqual(result.length, 3);
          assert(result.every((b) => !b.archived), 'None should be archived');
        });

        await test('includes bins without archived property', () => {
          const result = filterBins(bins);
          assert(result.some((b) => b.id === 'BIN-005'), 'Bins without archived flag should be included');
        });

        await test('shows all bins when showArchived is true', () => {
          const result = filterBins(bins, { showArchived: true });
          assertEqual(result.length, 5);
        });

        await test('handles empty array', () => {
          const result = filterBins([]);
          assertEqual(result.length, 0);
        });

        await test('handles all bins archived', () => {
          const allArchived = [
            { id: 'B1', archived: true },
            { id: 'B2', archived: true },
          ];
          const result = filterBins(allArchived);
          assertEqual(result.length, 0, 'Should return empty when all are archived');
        });

        await test('archive filtering in DB round-trip', async () => {
          await clearTestDb();
          await dbPutBin({ id: 'BIN-A1', name: 'Active', location: '', description: '', createdAt: '2026-01-15T10:00:00Z', archived: false });
          await dbPutBin({ id: 'BIN-A2', name: 'Archived', location: '', description: '', createdAt: '2026-01-15T10:00:00Z', archived: true });
          const allBins = await dbGetAllBins();
          const active = filterBins(allBins);
          assertEqual(active.length, 1);
          assertEqual(active[0].id, 'BIN-A1');
        });
      });

      // --------------------------------------------------------
      // SUITE: Fuse.js Cache Invalidation via dataVersion
      // --------------------------------------------------------
      await suite('Fuse Cache Invalidation', async () => {
        await clearTestDb();

        await test('dataVersion starts at a known value', () => {
          const v = dbGetDataVersion();
          assert(typeof v === 'number', 'dataVersion should be a number');
        });

        await test('putBin increments dataVersion', async () => {
          const before = dbGetDataVersion();
          await dbPutBin({ id: 'BIN-FV1', name: 'Test', location: '', description: '', createdAt: '2026-01-15T10:00:00Z' });
          const after = dbGetDataVersion();
          assert(after > before, `dataVersion should increment: was ${before}, now ${after}`);
        });

        await test('putItem increments dataVersion', async () => {
          const before = dbGetDataVersion();
          await dbPutItem({ id: 'item-fv1', binId: 'BIN-FV1', description: 'Test', photo: null, addedAt: '2026-01-16T10:00:00Z' });
          const after = dbGetDataVersion();
          assert(after > before, 'putItem should increment dataVersion');
        });

        await test('deleteItem increments dataVersion', async () => {
          const before = dbGetDataVersion();
          await dbDeleteItem('item-fv1');
          const after = dbGetDataVersion();
          assert(after > before, 'deleteItem should increment dataVersion');
        });

        await test('deleteBin increments dataVersion', async () => {
          const before = dbGetDataVersion();
          await dbDeleteBin('BIN-FV1');
          const after = dbGetDataVersion();
          assert(after > before, 'deleteBin should increment dataVersion');
        });

        await test('importAll increments dataVersion', async () => {
          const before = dbGetDataVersion();
          await dbImportAll({ bins: [{ id: 'BIN-IMP', name: '', location: '', description: '', createdAt: '2026-01-15T10:00:00Z' }], items: [] }, 'merge');
          const after = dbGetDataVersion();
          assert(after > before, 'importAll should increment dataVersion');
        });

        await test('Fuse index detects stale cache via dataVersion', async () => {
          await clearTestDb();
          const v1 = dbGetDataVersion();

          // Build initial Fuse index
          await dbPutBin({ id: 'BIN-F1', name: 'Alpha', location: '', description: '', createdAt: '2026-01-15T10:00:00Z' });
          const bins1 = await dbGetAllBins();
          const items1 = await dbGetAllItems();
          const entries1 = bins1.map((b) => ({ type: 'bin', id: b.id, name: b.name }));
          let fuseInstance = new Fuse(entries1, { keys: ['id', 'name'], threshold: 0.35 });
          let cachedVersion = dbGetDataVersion();

          // Mutate data
          await dbPutBin({ id: 'BIN-F2', name: 'Beta', location: '', description: '', createdAt: '2026-01-15T11:00:00Z' });

          // Check if cache is stale
          const currentVersion = dbGetDataVersion();
          assert(currentVersion > cachedVersion, 'Version should have changed');

          // Rebuild index
          const bins2 = await dbGetAllBins();
          const entries2 = bins2.map((b) => ({ type: 'bin', id: b.id, name: b.name }));
          fuseInstance = new Fuse(entries2, { keys: ['id', 'name'], threshold: 0.35 });
          cachedVersion = currentVersion;

          // Verify the new entry is searchable
          const searchResults = fuseInstance.search('Beta');
          assert(searchResults.length > 0, 'Beta should be found after index rebuild');
          assertEqual(searchResults[0].item.id, 'BIN-F2');
        });
      });

      // --------------------------------------------------------
      // SUITE: Pagination
      // --------------------------------------------------------
      await suite('Pagination', async () => {
        // Generate 55 test items
        const allItems = Array.from({ length: 55 }, (_, i) => ({
          id: `item-${i}`,
          description: `Item ${i}`,
          addedAt: new Date(2026, 0, 15, 10, i).toISOString(),
        }));

        await test('page 1 returns first 20 items', () => {
          const result = paginate(allItems, 1, 20);
          assertEqual(result.items.length, 20);
          assertEqual(result.items[0].id, 'item-0');
          assertEqual(result.items[19].id, 'item-19');
          assertEqual(result.page, 1);
          assertEqual(result.totalPages, 3);
          assertEqual(result.hasNext, true);
          assertEqual(result.hasPrev, false);
        });

        await test('page 2 returns items 20-39', () => {
          const result = paginate(allItems, 2, 20);
          assertEqual(result.items.length, 20);
          assertEqual(result.items[0].id, 'item-20');
          assertEqual(result.hasNext, true);
          assertEqual(result.hasPrev, true);
        });

        await test('last page returns remaining items', () => {
          const result = paginate(allItems, 3, 20);
          assertEqual(result.items.length, 15);
          assertEqual(result.items[0].id, 'item-40');
          assertEqual(result.hasNext, false);
          assertEqual(result.hasPrev, true);
        });

        await test('page beyond range returns empty items', () => {
          const result = paginate(allItems, 10, 20);
          assertEqual(result.items.length, 0);
          assertEqual(result.hasNext, false);
        });

        await test('totalPages is correct for exact multiples', () => {
          const items40 = allItems.slice(0, 40);
          const result = paginate(items40, 1, 20);
          assertEqual(result.totalPages, 2);
        });

        await test('totalItems is always the full count', () => {
          const result = paginate(allItems, 2, 20);
          assertEqual(result.totalItems, 55);
        });

        await test('pageSize of 1 works', () => {
          const result = paginate(allItems, 1, 1);
          assertEqual(result.items.length, 1);
          assertEqual(result.totalPages, 55);
        });

        await test('empty array returns 0 total pages', () => {
          const result = paginate([], 1, 20);
          assertEqual(result.items.length, 0);
          assertEqual(result.totalPages, 0);
          assertEqual(result.hasNext, false);
          assertEqual(result.hasPrev, false);
        });
      });

      // --------------------------------------------------------
      // SUITE: Fuse.js Search with Tags
      // --------------------------------------------------------
      await suite('Fuse.js Search with Tags', async () => {

        await test('tags field is searchable via Fuse', () => {
          const entries = [
            { type: 'item', id: 'i1', name: 'LED Strip', tags: ['electronics', 'lighting'] },
            { type: 'item', id: 'i2', name: 'Wood Screws', tags: ['hardware', 'fasteners'] },
            { type: 'item', id: 'i3', name: 'Resistor Pack', tags: ['electronics', 'components'] },
          ];
          const fuse = new Fuse(entries, {
            keys: ['id', 'name', 'tags'],
            threshold: 0.35,
          });
          const results = fuse.search('electronics');
          assertEqual(results.length, 2, 'Should find 2 electronics items');
          const ids = results.map((r) => r.item.id).sort();
          assert(ids.includes('i1'), 'Should find LED Strip');
          assert(ids.includes('i3'), 'Should find Resistor Pack');
        });

        await test('tag search does not match unrelated items', () => {
          const entries = [
            { type: 'item', id: 'i1', name: 'Bolts', tags: ['hardware'] },
            { type: 'item', id: 'i2', name: 'Wire', tags: ['electronics'] },
          ];
          const fuse = new Fuse(entries, {
            keys: ['id', 'name', 'tags'],
            threshold: 0.35,
          });
          const results = fuse.search('hardware');
          assertEqual(results.length, 1);
          assertEqual(results[0].item.id, 'i1');
        });

        await test('items without tags are still searchable by name', () => {
          const entries = [
            { type: 'item', id: 'i1', name: 'Duct Tape', tags: [] },
            { type: 'item', id: 'i2', name: 'Masking Tape' },
          ];
          const fuse = new Fuse(entries, {
            keys: ['id', 'name', 'tags'],
            threshold: 0.35,
          });
          const results = fuse.search('tape');
          assertEqual(results.length, 2, 'Both items should match by name');
        });
      });

      // --------------------------------------------------------
      // SUITE: Edge Cases & Integration
      // --------------------------------------------------------
      await suite('Edge Cases & Integration', async () => {
        await clearTestDb();

        await test('export then import round-trip preserves data', async () => {
          await dbPutBin({ id: 'BIN-RT1', name: 'Round Trip', location: 'Lab', description: 'Test', createdAt: '2026-01-15T10:00:00Z' });
          await dbPutItem({ id: 'item-rt1', binId: 'BIN-RT1', description: 'Widget', photo: null, addedAt: '2026-01-16T10:00:00Z' });
          await dbPutItem({ id: 'item-rt2', binId: 'BIN-RT1', description: 'Gadget', photo: null, addedAt: '2026-01-16T11:00:00Z' });

          const exported = await dbExportAll();
          await dbImportAll(exported, 'replace');

          const bin = await dbGetBin('BIN-RT1');
          assertEqual(bin.name, 'Round Trip');
          const items = await dbGetItemsByBin('BIN-RT1');
          assertEqual(items.length, 2);
        });

        await test('sorting after import works correctly', async () => {
          await clearTestDb();
          await dbImportAll({
            bins: [{ id: 'BIN-S1', name: 'Sorted', location: '', description: '', createdAt: '2026-01-15T10:00:00Z' }],
            items: [
              { id: 'is1', binId: 'BIN-S1', description: 'Zebra', photo: null, addedAt: '2026-01-16T10:00:00Z' },
              { id: 'is2', binId: 'BIN-S1', description: 'Apple', photo: null, addedAt: '2026-01-17T10:00:00Z' },
              { id: 'is3', binId: 'BIN-S1', description: 'Mango', photo: null, addedAt: '2026-01-15T10:00:00Z' },
            ],
          }, 'replace');
          const items = await dbGetItemsByBin('BIN-S1');
          const sorted = sortItems(items, 'a-z');
          assertEqual(sorted[0].description, 'Apple');
          assertEqual(sorted[1].description, 'Mango');
          assertEqual(sorted[2].description, 'Zebra');
        });

        await test('archive filter combined with pagination', () => {
          const bins = Array.from({ length: 50 }, (_, i) => ({
            id: `BIN-${String(i).padStart(3, '0')}`,
            name: `Bin ${i}`,
            archived: i % 3 === 0,
          }));
          const active = filterBins(bins);
          const page1 = paginate(active, 1, 20);
          assert(page1.items.length <= 20, 'Page should have at most 20 items');
          assert(page1.items.every((b) => !b.archived), 'Page should contain no archived bins');
          assert(page1.totalItems < 50, 'Total should be less than 50 after filtering');
        });

        await test('tags parsed and attached to item before DB storage', async () => {
          await clearTestDb();
          await dbPutBin({ id: 'BIN-T1', name: 'Tagged', location: '', description: '', createdAt: '2026-01-15T10:00:00Z' });
          const tags = parseTags('electronics, Resistors, 10k');
          const item = {
            id: 'item-tag1',
            binId: 'BIN-T1',
            description: '10k Resistor Pack',
            photo: null,
            tags: tags,
            addedAt: '2026-01-16T10:00:00Z',
          };
          await dbPutItem(item);
          const retrieved = await dbGetItem('item-tag1');
          assertDeepEqual(retrieved.tags, ['electronics', 'resistors', '10k']);
        });

        await test('importing data with missing bins/items keys is handled gracefully', async () => {
          await clearTestDb();
          // importAll uses (data.bins || []) and (data.items || []), so missing keys should not throw
          let error = null;
          try {
            await dbImportAll({}, 'merge');
          } catch (e) {
            error = e;
          }
          assertEqual(error, null, 'importAll should handle missing bins/items keys');
          const counts = await dbGetCounts();
          assertEqual(counts.bins, 0);
          assertEqual(counts.items, 0);
        });
      });

      // --------------------------------------------------------
      // CLEANUP
      // --------------------------------------------------------
      await destroyTestDb();
      renderResults();
    }

    // Run!
    runAllTests().catch((e) => {
      document.getElementById('running').textContent = 'Fatal error: ' + e.message;
      console.error(e);
    });
  </script>
</body>
</html>